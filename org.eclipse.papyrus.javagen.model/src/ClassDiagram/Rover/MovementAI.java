// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package ClassDiagram.Rover;

import ClassDiagram.Rover.HardwareHandler;
import ClassDiagram.Rover.MovementManager;
import ClassDiagram.Rover.Observer;
import ClassDiagram.Types.Area;
import ClassDiagram.Types.Environment;
import ClassDiagram.Types.Point;
import ClassDiagram.Types.Position;
import ClassDiagram.Types.SensorData;
import ClassDiagram.Types.UpdateEvent;
import ClassDiagram.Types.UpdateEventType;
import java.util.*;


/************************************************************/
/**
 * 
 */
public class MovementAI implements MovementManager, Observer {
	private enum RoverState {
		NORMAL, AVOIDING_OBSTACLE, WAITING_FOR_ROOM, ENTERING_ROOM
	}
	
	/**
	 * 
	 */
	private HardwareHandler hardwareHandler;
	private Environment environment;

	private Point targetPoint ;
	private Position lastPosition;
	private List<Observer> observers = new LinkedList<Observer>();
	private SensorData sensorData;
	private RoverState roverState = RoverState.NORMAL;
	
	
	/**
	 * 
	 * @param environment 
	 */
	public MovementAI(Environment environment, HardwareHandler hardwareHandler) {
		this.hardwareHandler = hardwareHandler;
		this.environment = environment;
		hardwareHandler.addObserver(this);
		
		for (Area a : environment.getAreas()) {
			acquiredArea.put(a, false);
		}
	}

	
	/**
	 * 
	 * @param point 
	 */
	public void goToPoint(Point point) {
		targetPoint = point;
		hardwareHandler.setDestination(targetPoint.position);
	}

	/**
	 * 
	 * @param observer 
	 */
	public void addObserver(Observer observer) {
		observers.add(observer);
	}

	/**
	 * 
	 * @param observer 
	 */
	public void removeObserver(Observer observer) {
		observers.remove(observer);
	}
	
	private void processMovement(Position position) {
		if (lastPosition == null) {
			lastPosition = position;
		}
		
		if (roverState == RoverState.NORMAL) {
			if (checkObstacle(position)) {
				//roverState = RoverState.AVOIDING_OBSTACLE;
			} else if (checkRoomAccess(position)) {
				roverState = RoverState.WAITING_FOR_ROOM;
			}
		}
		
		switch (roverState) {
		case AVOIDING_OBSTACLE:
			handleObstacle(position);
			break;
		case WAITING_FOR_ROOM:
			handleRoomAccess();
			break;
		case ENTERING_ROOM:
			handleRoomEntry(position);
			break;
		default:
			// check if point is reached
			if(position.distanceTo(targetPoint.position) < 0.2) {
				for(Observer o : observers) {
					o.update(new UpdateEvent(UpdateEventType.PointReachedUpdate,targetPoint));
				}
			}
		}
		
		lastPosition = position;
	}
	
	private boolean checkObstacle(Position position) {
		return sensorData != null && sensorData.frontDistance < 5;
	}
	
	private void handleObstacle(Position position) {
		boolean inFront = false;
		boolean toSide = false;
		
		// Cannot do anything safely without sensor data, so we return
		if(sensorData == null) return;

		/*
		 * If wall in front
		 * 		Rotate the current velocity 90 degrees and remove the smaller component, axis-aligning it.
		 * Else if wall to the left
		 * 		Move forward
		 * Else
		 * 		Move toward point
		 * 
		 */
		
		Position lookDirection = new Position(position.x  - lastPosition.x, position.z - lastPosition.z);
		
		// Normalize look dir
		double len = Math.sqrt(lookDirection.x * lookDirection.x + lookDirection.z * lookDirection.z);
		lookDirection.x /= len;
		lookDirection.z /= len;

        //lookDirection.x *= 100;
        //lookDirection.z *= 100;

		// Angle code appears to be working correctly, but setting the destination causes strange behaviors
		// If something is in front, keep turning right
		if(sensorData.frontDistance < 5) {

			// Turn right (very slowly, speed up once bugs are fixed)
			double angle = Math.toRadians(1);
			
            lookDirection =
                    new Position(
                            Math.cos(angle) * lookDirection.x - Math.sin(angle) * lookDirection.z,
                            Math.sin(angle) * lookDirection.x + Math.cos(angle) * lookDirection.z
                    );
			
			hardwareHandler.setDestination(new Position(lookDirection.x + position.x, lookDirection.z + position.z));
			
			inFront = true;
		}
		// If nothing is in front, but something is on the left, move forward
		else if(sensorData.leftDistance < 5) {

			hardwareHandler.setDestination(new Position(lookDirection.x + position.x, lookDirection.z + position.z));
			toSide = true;
		}
		// If nothing is detected, we've avoided the obstacle
		else
		{
			roverState = RoverState.NORMAL;
			hardwareHandler.setDestination(targetPoint.position);
		}
	}

	private HashMap<Area, Boolean> acquiredArea = new HashMap<Area, Boolean>();
	private Area waitedArea;
	private boolean checkRoomAccess(Position position) {
		// guess next position
		Position nextPosition = new Position(
				position.x + (position.x - lastPosition.x),
				position.z + (position.z - lastPosition.z)
			);
		
		for (Area a : environment.getAreas()) {
			if (a.getLocationController() != null) {
				// have we left a?
				if (acquiredArea.get(a) && !a.getBoundary().contains(position) &&
						!a.getBoundary().contains(nextPosition)) {
					acquiredArea.put(a, false);
					a.getLocationController().release((Robot)hardwareHandler);
				}
				
				// are we about to move into a?
				if (!acquiredArea.get(a) && a.getBoundary().contains(nextPosition)) {
					waitedArea = a;
					hardwareHandler.stop();
					return true;
				}
			}
		}
		return false;
	}
	
	private void handleRoomAccess() {
		if (waitedArea.getLocationController().tryAcquire((Robot)hardwareHandler)) {
			acquiredArea.put(waitedArea,  true);
			hardwareHandler.setDestination(targetPoint.position);
			roverState = RoverState.ENTERING_ROOM;
		}
	}
	
	private double wakeupTime = Double.POSITIVE_INFINITY;
	private void handleRoomEntry(Position position) {
		double time = hardwareHandler.getLifeTime();
		
		if (!waitedArea.requiresWaiting()) {
			roverState = RoverState.NORMAL;
		} else if (wakeupTime == Double.POSITIVE_INFINITY &&
				waitedArea.getBoundary().contains(position)) {
			// stop and set the timer if we have just entered the room
			hardwareHandler.stop();
			wakeupTime = time + 2;
		} else if (time >= wakeupTime) {
			// resume mission if wait is done
			roverState = RoverState.NORMAL;
			hardwareHandler.setDestination(targetPoint.position);
			wakeupTime = Double.POSITIVE_INFINITY;
		}
	}

	/**
	 * 
	 * @param updateEvent 
	 */
	public void update(UpdateEvent updateEvent) {
		switch(updateEvent.type) {
			case PositionUpdate:
				processMovement((Position) updateEvent.data);
				return;
			case SensorUpdate:
				sensorData = (SensorData) updateEvent.data;
				break;
			default:
				break;
		}
	}
	
	
};










