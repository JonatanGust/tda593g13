// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package ClassDiagram.Rover;

import ClassDiagram.Rover.HardwareHandler;
import ClassDiagram.Rover.MovementManager;
import ClassDiagram.Rover.Observer;
import ClassDiagram.Types.Area;
import ClassDiagram.Types.Environment;
import ClassDiagram.Types.Point;
import ClassDiagram.Types.Position;
import ClassDiagram.Types.SensorData;
import ClassDiagram.Types.UpdateEvent;
import ClassDiagram.Types.UpdateEventType;
import java.util.*;


/************************************************************/
/**
 * 
 */
public class MovementAI implements MovementManager, Observer {
	/**
	 * 
	 */
	private HardwareHandler hardwareHandler;
	private Environment environment;

	private Point targetPoint ;
	private Position lastPosition = new Position(0.0,0.0);
	private double lookAngle;
	private Position nextPosition;
	private boolean hasStopped = true;
	
	private List<Observer> observers = new LinkedList<Observer>();
	
	private HashMap<Area, Boolean> acquiredArea = new HashMap<Area, Boolean>();
	
	private SensorData sensorData;

	private boolean avoidingObstacle = false;
	
	/**
	 * 
	 * @param environment 
	 */
	public MovementAI(Environment environment, HardwareHandler hardwareHandler) {
		this.hardwareHandler = hardwareHandler;
		this.environment = environment;
		nextPosition = hardwareHandler.getCurrentPosition();
		hardwareHandler.addObserver(this);
		
		for (Area a : environment.getAreas()) {
			acquiredArea.put(a, false);
		}
	}

	
	/**
	 * 
	 * @param point 
	 */
	public void goToPoint(Point point) {
		targetPoint = point;
		hardwareHandler.setDestination(targetPoint.position);
		hasStopped = false;
	}

	/**
	 * 
	 * @param observer 
	 */
	public void addObserver(Observer observer) {
		observers.add(observer);
	}

	/**
	 * 
	 * @param observer 
	 */
	public void removeObserver(Observer observer) {
		observers.remove(observer);
	}
	
	private void processMovement(Position position) {

		boolean inFront = false;
		boolean toSide = false;
		
		// Cannot do anything safely without sensor data, so we return
		if(sensorData == null) return;

		/*
		 * If wall in front
		 * 		Rotate the current velocity 90 degrees and remove the smaller component, axis-aligning it.
		 * Else if wall to the left
		 * 		Move forward
		 * Else
		 * 		Move toward point
		 * 
		 */
		
		Position lookDirection = new Position(position.x  - lastPosition.x, position.z - lastPosition.z);
		
		// Normalize look dir
		double len = Math.sqrt(lookDirection.x * lookDirection.x + lookDirection.z * lookDirection.z);
		lookDirection.x /= len;
		lookDirection.z /= len;

        //lookDirection.x *= 100;
        //lookDirection.z *= 100;

		// Angle code appears to be working correctly, but setting the destination causes strange behaviors
		if(avoidingObstacle) {
			// If something is in front, keep turning right
			if(sensorData.frontDistance < 5) {

				// Turn right (very slowly, speed up once bugs are fixed)
				double angle = Math.toRadians(1);
				
	            lookDirection =
	                    new Position(
	                            Math.cos(angle) * lookDirection.x - Math.sin(angle) * lookDirection.z,
	                            Math.sin(angle) * lookDirection.x + Math.cos(angle) * lookDirection.z
	                    );
				
				hardwareHandler.setDestination(new Position(lookDirection.x + position.x, lookDirection.z + position.z));
				
				inFront = true;
			}
			// If nothing is in front, but something is on the left, move forward
			else if(sensorData.leftDistance < 5) {

				hardwareHandler.setDestination(new Position(lookDirection.x + position.x, lookDirection.z + position.z));
				toSide = true;
			}
			// If nothing is detected, we've avoided the obstacle
			else
			{
				avoidingObstacle = false;
			}
		}
		else {
			if(sensorData.frontDistance < 5) {
				avoidingObstacle = true;
			}
			else {
				// Move toward target
				if(targetPoint != null) {
					hardwareHandler.setDestination(targetPoint.position);	
					
					lastPosition = position;
					
					double curX =  position.x;
					double curY =  position.z;
					double targetX = targetPoint.position.x;
					double targetY = targetPoint.position.z;
					double dist = Math.pow(targetX - curX, 2.0) + Math.pow(targetY - curY, 2.0) ;
					if(dist < 0.1) {
						for(Observer o : observers) {
							o.update(new UpdateEvent(UpdateEventType.PointReachedUpdate,targetPoint));
						}
					}
				
				}
			}

			for (Area a : environment.getAreas()) {
				if (a.getLocationController() != null) {
					if (acquiredArea.get(a) && !a.getBoundary().contains(position) &&
							!a.getBoundary().contains(nextPosition)) {
						acquiredArea.put(a, false);
						a.getLocationController().release((Robot)hardwareHandler);
					}
					if (a.getBoundary().contains(nextPosition)) {
						if (acquiredArea.get(a)) {
							hardwareHandler.setDestination(targetPoint.position);
							hasStopped = false;
						} else if (a.getLocationController().tryAcquire((Robot)hardwareHandler)) {
							acquiredArea.put(a, true);
							hardwareHandler.setDestination(targetPoint.position);
							hasStopped = false;
						} else {
							hasStopped = true;
							hardwareHandler.stop();									
						}
					}
				}
			}
		}
		
		lastPosition = position;
	}
	

	/**
	 * 
	 * @param updateEvent 
	 */
	public void update(UpdateEvent updateEvent) {
		switch(updateEvent.type) {
			case PositionUpdate:
				processMovement((Position) updateEvent.data);
				return;
			case SensorUpdate:
				sensorData = (SensorData) updateEvent.data;
				break;
			default:
				break;
		}
	}
	
	
};










