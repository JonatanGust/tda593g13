// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package ClassDiagram.Rover;

import ClassDiagram.Rover.HardwareHandler;
import ClassDiagram.Rover.MovementManager;
import ClassDiagram.Rover.Observer;
import ClassDiagram.Types.Environment;
import ClassDiagram.Types.Point;
import ClassDiagram.Types.Position;
import ClassDiagram.Types.SensorData;
import ClassDiagram.Types.UpdateEvent;
import ClassDiagram.Types.UpdateEventType;
import java.util.*;


/************************************************************/
/**
 * 
 */
public class MovementAI implements MovementManager, Observer {
	/**
	 * 
	 */
	private HardwareHandler hardwareHandler;
	private Environment environment;

	private Point targetPoint ;
	private Position lastPosition = new Position(0.0,0.0);
	private double lookAngle;
	
	List<Observer> observers = new LinkedList<Observer>();
	
	SensorData sensorData;
	
	/**
	 * 
	 * @param environment 
	 */
	public MovementAI(Environment environment, HardwareHandler hardwareHandler) {
		this.hardwareHandler = hardwareHandler;
		this.environment = environment;
		hardwareHandler.addObserver(this);
	}

	
	/**
	 * 
	 * @param point 
	 */
	public void goToPoint(Point point) {
		targetPoint = point;
		hardwareHandler.setDestination(targetPoint.position);
	}

	/**
	 * 
	 * @param observer 
	 */
	public void addObserver(Observer observer) {
		observers.add(observer);
	}

	/**
	 * 
	 * @param observer 
	 */
	public void removeObserver(Observer observer) {
		observers.remove(observer);
	}
	
	private void processMovement(Position position) {
		

		
		lookAngle = Math.tan(
			 	position.z - lastPosition.z /
				position.x  - lastPosition.x
			);
		
				
		if(sensorData != null && sensorData.frontDistance < 5)
		{
			// This probably doesn't work but it might
			
			// Turn right 45 degrees
			double relativeX = targetPoint.position.x - position.x;
			double relativeZ = targetPoint.position.z - position.z;
			double ang = Math.toRadians(lookAngle + 45);
			hardwareHandler.setDestination(
					new Position(
							Math.cos(ang) * relativeX - Math.sin(ang) * relativeZ,
							Math.sin(ang) * relativeX + Math.cos(ang) * relativeZ
					)
				);
		}
		
		if(targetPoint != null) {
			hardwareHandler.setDestination(targetPoint.position);
		}
		
		// Move toward targetPoint
		
		
		// If sensors indicate obstacle, turn away
		lastPosition = position;
	}

	/**
	 * 
	 * @param updateEvent 
	 */
	public void update(UpdateEvent updateEvent) {
		switch(updateEvent.type) {
			case PositionUpdate:
				processMovement((Position) updateEvent.data);
				return;
			case SensorUpdate:
				sensorData = (SensorData) updateEvent.data;
				break;
			default:
				break;
		}
	}
	
	
};










