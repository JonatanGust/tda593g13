// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package ClassDiagram.Rover;

import ClassDiagram.Rover.HardwareHandler;
import ClassDiagram.Rover.MovementManager;
import ClassDiagram.Rover.Observer;
import ClassDiagram.Types.Area;
import ClassDiagram.Types.Environment;
import ClassDiagram.Types.Point;
import ClassDiagram.Types.Position;
import ClassDiagram.Types.SensorData;
import ClassDiagram.Types.UpdateEvent;
import ClassDiagram.Types.UpdateEventType;
import java.util.*;


/************************************************************/
/**
 * 
 */
public class MovementAI implements MovementManager, Observer {
	/**
	 * 
	 */
	private HardwareHandler hardwareHandler;
	private Environment environment;

	private Point targetPoint ;
	private Position lastPosition = new Position(0.0,0.0);
	private double lookAngle;
	
	private List<Observer> observers = new LinkedList<Observer>();
	
	private HashMap<Area, Boolean> acquiredArea = new HashMap<Area, Boolean>();
	
	private SensorData sensorData;
	
	/**
	 * 
	 * @param environment 
	 */
	public MovementAI(Environment environment, HardwareHandler hardwareHandler) {
		this.hardwareHandler = hardwareHandler;
		this.environment = environment;
		hardwareHandler.addObserver(this);
		
		for (Area a : environment.getAreas()) {
			acquiredArea.put(a, false);
		}
	}

	
	/**
	 * 
	 * @param point 
	 */
	public void goToPoint(Point point) {
		targetPoint = point;
		hardwareHandler.setDestination(targetPoint.position);
	}

	/**
	 * 
	 * @param observer 
	 */
	public void addObserver(Observer observer) {
		observers.add(observer);
	}

	/**
	 * 
	 * @param observer 
	 */
	public void removeObserver(Observer observer) {
		observers.remove(observer);
	}
	
	private void processMovement(Position position) {
		
		double xSpeed = position.x - lastPosition.x;
		double zSpeed = position.z - lastPosition.z;
		Position nextPos = new Position(position.x + xSpeed, position.z + zSpeed);

		
		lookAngle = Math.tan(
			 	position.z - lastPosition.z /
				position.x  - lastPosition.x
			);
		
				
		if(sensorData != null && sensorData.frontDistance < 5)
		{
			// This probably doesn't work but it might
			
			// Turn right 45 degrees
			double relativeX = targetPoint.position.x - position.x;
			double relativeZ = targetPoint.position.z - position.z;
			double ang = Math.toRadians(lookAngle + 45);
			hardwareHandler.setDestination(
					new Position(
							Math.cos(ang) * relativeX - Math.sin(ang) * relativeZ,
							Math.sin(ang) * relativeX + Math.cos(ang) * relativeZ
					)
				);
		}
		
		if(targetPoint != null) {
			hardwareHandler.setDestination(targetPoint.position);	
			
			lastPosition = position;
			
			double curX =  position.x;
			double curY =  position.z;
			double targetX = targetPoint.position.x;
			double targetY = targetPoint.position.z;
			double dist = Math.pow(targetX - curX, 2.0) + Math.pow(targetY - curY, 2.0) ;
			if(dist < 0.1) {
				for(Observer o : observers) {
					o.update(new UpdateEvent(UpdateEventType.PointReachedUpdate,targetPoint));
				}
			}
		
		}
		
		// Move toward targetPoint
		
		
		// If sensors indicate obstacle, turn away

		for (Area a : environment.getAreas()) {
			if (a.getLocationController() != null) {
				if (a.getBoundary().contains(nextPos)) {
					if (acquiredArea.get(a) || a.getLocationController().tryAcquire((Robot)hardwareHandler)) {
						acquiredArea.put(a, true);
						hardwareHandler.setDestination(targetPoint.position);
					} else {
						hardwareHandler.stop();									
					}
				} else {
					if (acquiredArea.get(a)) {
						acquiredArea.put(a, false);
						a.getLocationController().release((Robot)hardwareHandler);
					}
				}
			}
		}
	}
	

	/**
	 * 
	 * @param updateEvent 
	 */
	public void update(UpdateEvent updateEvent) {
		switch(updateEvent.type) {
			case PositionUpdate:
				processMovement((Position) updateEvent.data);
				return;
			case SensorUpdate:
				sensorData = (SensorData) updateEvent.data;
				break;
			default:
				break;
		}
	}
	
	
};










