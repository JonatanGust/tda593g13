// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package ClassDiagram.Rover;

import ClassDiagram.Rover.HardwareHandler;
import ClassDiagram.Rover.MovementManager;
import ClassDiagram.Rover.Observer;
import ClassDiagram.Types.Area;
import ClassDiagram.Types.Environment;
import ClassDiagram.Types.Point;
import ClassDiagram.Types.Position;
import ClassDiagram.Types.SensorData;
import ClassDiagram.Types.UpdateEvent;
import ClassDiagram.Types.UpdateEventType;
import java.util.*;


/************************************************************/
/**
 * 
 */
public class MovementAI implements MovementManager, Observer {
	/**
	 * 
	 */
	private HardwareHandler hardwareHandler;
	private Environment environment;

	private Point targetPoint ;
	private Position lastPosition = new Position(0.0,0.0);
	private double lookAngle;
	private Position nextPosition;
	private boolean hasStopped = true;
	
	private List<Observer> observers = new LinkedList<Observer>();
	
	private HashMap<Area, Boolean> acquiredArea = new HashMap<Area, Boolean>();
	
	private SensorData sensorData;
	
	/**
	 * 
	 * @param environment 
	 */
	public MovementAI(Environment environment, HardwareHandler hardwareHandler) {
		this.hardwareHandler = hardwareHandler;
		this.environment = environment;
		nextPosition = hardwareHandler.getCurrentPosition();
		hardwareHandler.addObserver(this);
		
		for (Area a : environment.getAreas()) {
			acquiredArea.put(a, false);
		}
	}

	
	/**
	 * 
	 * @param point 
	 */
	public void goToPoint(Point point) {
		targetPoint = point;
		hardwareHandler.setDestination(targetPoint.position);
		hasStopped = false;
	}

	/**
	 * 
	 * @param observer 
	 */
	public void addObserver(Observer observer) {
		observers.add(observer);
	}

	/**
	 * 
	 * @param observer 
	 */
	public void removeObserver(Observer observer) {
		observers.remove(observer);
	}
	
	private void processMovement(Position position) {
		
		

		
		lookAngle = Math.tan(
			 	position.z - lastPosition.z /
				position.x  - lastPosition.x
			);
		
				
		if(sensorData != null && sensorData.frontDistance < 5)
		{
			// This probably doesn't work but it might
			
			// Turn right 45 degrees
			double relativeX = targetPoint.position.x - position.x;
			double relativeZ = targetPoint.position.z - position.z;
			double ang = Math.toRadians(lookAngle + 45);
			hardwareHandler.setDestination(
					new Position(
							Math.cos(ang) * relativeX - Math.sin(ang) * relativeZ,
							Math.sin(ang) * relativeX + Math.cos(ang) * relativeZ
					)
				);
		}
		
		if(targetPoint != null) {			
			double curX =  position.x;
			double curY =  position.z;
			double targetX = targetPoint.position.x;
			double targetY = targetPoint.position.z;
			double dist = Math.pow(targetX - curX, 2.0) + Math.pow(targetY - curY, 2.0) ;
			if(dist < 0.1) {
				for(Observer o : observers) {
					o.update(new UpdateEvent(UpdateEventType.PointReachedUpdate,targetPoint));
				}
			}
		
		}
		
		// Move toward targetPoint
		
		
		// If sensors indicate obstacle, turn away
		if (!hasStopped) {
			double xSpeed = (position.x - lastPosition.x) * 2;
			double zSpeed = (position.z - lastPosition.z) * 2;
			nextPosition = new Position(position.x + xSpeed, position.z + zSpeed);
			lastPosition = position;
		}

		for (Area a : environment.getAreas()) {
			if (a.getLocationController() != null) {
				if (acquiredArea.get(a) && !a.getBoundary().contains(position) &&
						!a.getBoundary().contains(nextPosition)) {
					acquiredArea.put(a, false);
					a.getLocationController().release((Robot)hardwareHandler);
				}
				if (a.getBoundary().contains(nextPosition)) {
					if (acquiredArea.get(a)) {
						hardwareHandler.setDestination(targetPoint.position);
						hasStopped = false;
					} else if (a.getLocationController().tryAcquire((Robot)hardwareHandler)) {
						acquiredArea.put(a, true);
						hardwareHandler.setDestination(targetPoint.position);
						hasStopped = false;
					
					} else {
						hasStopped = true;
						hardwareHandler.stop();									
					}
				}
			}
		}
	}
	

	/**
	 * 
	 * @param updateEvent 
	 */
	public void update(UpdateEvent updateEvent) {
		switch(updateEvent.type) {
			case PositionUpdate:
				processMovement((Position) updateEvent.data);
				return;
			case SensorUpdate:
				sensorData = (SensorData) updateEvent.data;
				break;
			default:
				break;
		}
	}
	
	
};










